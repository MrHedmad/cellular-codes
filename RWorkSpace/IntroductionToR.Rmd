---
title: "Short Introduction to R"
author: 'Visentin Luca'
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
---
# Part 1: Introduction
R is a high-level programming language, mostly used in statistical computing. A high-level programming language uses-human like syntax to run calculations. This notebook is aimed at explaining such a syntax and showing the most basic usages of R. Code chunks are clearly marked inside a light-gray box, with their output just below them, in a white box. Note that results are preceded by "##".

Comments in R code are marked by adding a "#" at the start of the line. Comments are not run, and usually used to describe what is going on in the code. R simply ignores what is after a # (until a new line).
```{r}
print("Hello!")  # This prints hello. This comment is ignored by R

# print("Hello, again!") This will do nothing, as it is in a comment.
```

On a command prompt, open the R console using the command "R". The console allows for interactive use of R.
The default console prompt is ">". If a command is detected to be incomplete, a "+" prompt will appear, until the command is completed. Esc escapes from the + prompt.
Here's some R code. Notice that every command is given in a line, or several in-line comments are divided by a semicolon (;):
```{r}
my.variable <- list(c("I'm some text"), c(1, 2, 3, 4))
my.variable
mean(my.variable[[2]]) -> my.mean ; my.mean # Notice the semicolon here
```
Spaces are completely ignored by R code. To this end, `print("Hello")` is the same of `pr int( "Hello"  )`.
Help files are available for most functions. You can get help by using ? or ?? and then the name of the function to look up. Use ?*function* if you know the exact name of the function, or ??*query* to search R's help files for some *query*. For example, `?median` and `??logarithm`.

### 1.1 The Working Directory
As R works and creates data, it will, by default, save and edit data present in its working directory (WD). The Working Directory is a folder on the PC, and the current WD can be viewed with the command `getwd()`. For most uses present in this notebook, the WD will not matter; however, if data needs to be loaded in R, it must be present in the WD. To change the WD, we can use `setwd("Path")`, for example `setwd("c:/Users/Luca/RWorkspace")`.
In R Studio, to change the default working directory, go to: Tools > Global Options > General and change the default path. Files are read and written from / to the W.D. (See "Writing and reading files").
R is case-sensitive. A and a are different characters.
```{r}
a <- c("This is the variable a") ; a
A <- c("This is a new variable A") ; A
```
For all intents and purposes, A and a are two different objects.

# Part 2: Functions and Assignments
A function is a set of instructions that R follows to get a result. A function can be called with FUN_NAME( arg1, arg2, arg3, ...). FUN_NAME is the name of the function, while arg1,... are its arguments. A function RETURNS its result after it is run. Returning a result either hands the result to another function for further processing, or sometimes prints the result for the user to see.
```{r}
rep(x = 1:3, times = 4)
```
In this case, we use the function named rep, which repeats its "x" argument a "times" times. 
We can omit the name of the arguments if we follow the order of the arguments as shown in `?rep()`. By running `?rep()`, we see that the default order of arguments is rep(x, times). The next three examples will give the exact same output:
```{r results = "hold"}
rep(x = 1:3, times = 3)
rep(1:3, 3)
rep(times = 3, x = 1:3) # We can change the order of the args, if we specify them.
```
Commands can be nested inside each other. R will run them in the correct order that is, from the inner-most to the outer-most. This next example runs rep(), then sum() on whatever rep() returned.
```{r}
sum( rep(1:5, 5) )
```
When we run a function, the result is usually printed, but then lost. We can **assign** what a function returns to a variable for storage and re-use. After we assign, **calling** the variable will be the same of running the function. The assignment operator is `<-` (or `->`). `=` is the same as `<-`, but `<-` is preferred.

For example: `x <- 15` will store 15 into the variable x (remember that x and X are different variables for R!). On the other hand, `x -> y` will store what is inside the variable x into the variable y (notice where the arrow is pointing). So, `x <- 15` can be interpreted as "Put 15 inside the variable x". 
```{r}
x <- rep(1:5, 5) # Assignments don't return anything in the console (if working).
sum(x)           # This is the same as sum( rep(1:5, 5) ) from before.

x                # Just writing the variable name will print its contents out.
```
# Part 3: Objects
All variables are objects. Created objects can be listed with `objects()` or `ls()`. Every output, even what is printed with "`objects()`", is itself an object. If an object is not assigned as it is created, it is printed out and then lost (Or "*garbage collected*").
We can remove assigned objects using `rm()`.
```{r}
x <- c("Banana", "Papaya", "Guava") 
y <- c(1, 2, 3, 4, 5)

objects() # This will print out all variable created thus far, even the ones in the examples above.

rm("x") # This will delete (PERMANENTLY) the object x from the environment.
```
Objects have a set of characteristics:

* `mode()` shows us what type of data is inside the object. This can be "numeric", "logical", "character", "list"...
* Every object can have one or several *attributes*, such as a name.
* Every object is encoded (meaning stored) in a particular fashion known as a data structure. We will explore types of data structures later.
```{r}
mode(y) # Since y is a set of numbers, this returns "numeric".
```
As we will see later, we can set the attributes of our objects. For example, `names()` is a type of attribute. We can list user-set attributes with:
```{r}
attributes(y) # Since we set none, it returns NULL
```
You can get what type of data structure (more or less) an object is:
```{r}
class(y) # This returns "numeric"
class(data.frame(y)) # This returns "data.frame" as data.frame(y) is a data frame.
```
Remember that functions are objects too!
Objects are stored to what is called *The environment*. For example, when we run in the console `x <- 15`, we create (or overwrite) the variable "x" in the **Global environment**. As a function runs, it might create internal variables to manipulate intermediate results. These variables are places in a function's **local environment**, so, even if a function uses, is its process, a variable called "x", it will **not** overwrite the variable "x" in the global environment. A function could, in theory, place functions in the global environment, but this is almost never done if not for a very particular reason.

# Part 4: Data structures
## Vectors

Remember: The entities that R creates (functions too), are called objects. To get a list of object created use `objects()`. To remove (forever) a created object, use `rm(OBJ1, OBJ2, ...)`. Each object can encode its data in a different way, also called its *data structure*.

The basic data structure is the vector. The chain c() command creates a vector. Each element of the vector is separated from the next using a comma. Numbers are simply typed out, and decimal places are separated with a dot. Strings (words) must be enclosed in quotation marks, either `""` or `''`. if you need to use quotation marks inside a string element, either use the other type to enclose the string or escape them. See the following examples:
```{r}
c(1,2,3,4,5) # vector containing the numbers 1 to 5
c("This is a vector", "Containing only", "Character entities", "3", "64.5")
c('I\'m very hungry') # Quotes are escaped with \, but \\ is printed as "\\".
```

Remember that you can assign any object to a variable with "=" or "<-"/"->"
```{r}
x <- c(1,2,3,4)
c(1,2,3,4) -> x # These are the same
x <- c(1:4) # 1:4 means "1 through 4", and it results in the same as before
x # To print a variable simply type the variable's name
```

**A vector must contain the same type of data in each of its elements**. Some basic types of data are:
* Logic (TRUE or FALSE);
* Integer (1, 2, 3...);
* Numeric (1.0, 2.5, ...);
* Char ("The quick brown fox");
* Special such as:
    + NaN (Not a number, for example when trying to compute 5/0 or Infinity/Infinity)
    + Inf (for Infinity)
    + NA (Not available, used for example when some results are not recorded)
      - A special note for NA: When running an experiment, some results may be lost, so the necessity to "fill the gap" in data structures can arise. These "gaps" **must** be filled with NA, and not other number such as zero. This is because running `mean(c(1,2,3,NA))` will return NA (as the function has some arguments missing) while running mean(c(1,2,3,0) will return 1.5. In short, using 0 means that we *measured* the variable and it resulted in 0, while using NA means we *did not* measure the variable.

To get the mode of the vector use `mode(VECTOR)`.

To check if a vector is in a certain mode, use is.MODE:
```{r results ="hide"}
is.numeric(x)   # TRUE
is.character(x) # FALSE
is.logical(x)   # FALSE
is.double(x)    # FALSE
```

Trying to set a vector with multiple modes will try to coerce (meaning *adapt*) the modes into an acceptable one, or give out an error:
```{r}
x <- c("name", 1, 2, 3, "Banana") # Everything is coerced into Char
x # Notice the "" around each element, marking them as strings, and not numbers.
x <- c(1, 3, 10+0i, TRUE) # Again, everything is a complex number now. TRUE is coerced into 1, while FALSE is coerced into 0.
x
```

### Generating Vectors

Vectors can be generated in various ways. Simple 1-entity vectors can be made without c():
```{r}
x <- 2 # 2
x <- "Ciao" # "Ciao"
x <- -17+0.3i # Complex number - Note: sqrt(-17) is NaN, while sqrt(-17+0i) is computable. You can combine multiple vectors with c()

x <- c(1, 2, 3)
y <- c(4, 5, 6)

new.vector <- c(x, y) ; new.vector
```

For number sequences, we can use two methods. The simplest one is to use the "`:`" (column) operator, for example:
```{r results="hide"}
x <- 3:21 # Sequence of integers from 3 to 21, both included (3,4,5,6,...,20,21)
x <- 17:2 # (17,16,15,...,3,2)
```

More generally, we can use the function `seq()` to create number sequence. The variables for seq are: `seq(from, to, by, lenght.out, along.with, ...)` {Execute `?seq` for more information on this function}

```{r}
seq(f = 2, t = 4, by = 0.2)
```

Or, similarly, use `rep(x, times)`:
```{r}
x <- c(1, 2, 3)
rep(x, times = 5)

y <- c("A", "B", "C")
rep(y, each = 3)
```

For stitching together characters, use `paste(..., sep= " ")`. For example:
```{r}
paste(c("A", "T", "C", "G"), 1:5, sep = " banana ")
```

To get some random numbers following a normal distribution, use `rnorm()`:
```{r}
rnorm(n = 20, mean = 0, sd = 1)
```

Logic vectors contain either TRUE or FALSE (You could use T and F instead of TRUE and FALSE, but **DON'T**. T and F are variables that, by default, are assigned to TRUE and FALSE, but can be overwritten, and if they are and you run code using T and F thinking they are TRUE and FALSE, you may break everything).
```{r}
logic <- c(TRUE, FALSE, TRUE, TRUE)
logic
```

Logical vectors can be created by logical operators. logical operators are: 
* `>` Greater than;
* `<` Less than;
* `>=` Greater or Equal to;
* `<=` Less or Equal to;
* `==` Equal to (Remember that `=` is an assignment operator, so for comparisons you must use `==`) 
```{r results="hold"}
x <- 1:10
x > 8
x <= 2
x == 2
```

Or by logical expressions, & (and), | (or), ! (not):
```{r results="hold"}
x <- 1:10

x > 2 & x < 6 # Meaning "Where x is more than 2 AND less than 6"
x <= 3 | x >= 7 # Meaning "Where x is less or equal to 3 OR greater or equal to 7"

```

Missing values can be added by NA. Operations with NA return NA. "Not a Number" operations return NaN (See below for more on NA and NaN, as well as Inf and other special data).
```{r}
Inf - Inf
0 / 0
```

is.NA() will return TRUE for NA and NaN. is.NaN() will return TRUE only for NaN.

### Working with vectors

Now we will look at the most basic operations we can accomplish with vectors. For example, you can do basic math with vectors. [Note: A single number is, in fact, a vector with just a single element: `a <- 1` is the same as `a <- c(1)`].
```{r results = "hide"}
x <- c(1,2,3)
y <- c(4,5,6)

# Code  # Result
x + y   # 5 7 9          (sum)
x - y   # -3 -3 -3       (subtraction)
x * y   # 4 10 18        (multiplication)
x / y   # 0.25 0.40 0.50 (division)
x %% y  # 1 2 3          (x mod y)
x %/% y # 0 0 0          (integer division)
x ^ y   # 1 32 729       (power)
x ** y  # Same as ^
```
Notice how the first element of x is summed to the first element of y, then the second is summed to the second, etcetera. Other basic functions are:
```{r results="hide"}
max(x)  # 3 (Maximum value in x)
min(x)  # 1 (Minimum value in x)
log(x)  # Logarithm with, by default, e as base.
exp(x)  # Exponential with, by default, e as base.
sqrt(x) # Square root
mean(x) # 2 (Algebric Mean)

length(x) # 3 (How many elements are in the vector x?)
```
Let's assume that the lengths of the two vectors x and y differ:
```{r}
x <- c(1, 2, 3, 4, 5, 6, 7)
y <- c(10, 20)
```
Now we will try to sum them together. Observe the output.
```{r}
x + y
```
R begins to sum the two vectors: 1 + 10 = 11, 2 + 20 = 22, but then runs out of `y` numbers. So, it will **recycle** the numbers in `y` to complete the rest of the sum, so: 3 + 10 = 13, 4 + 20 = 24, etc... This is called the **recycle rule**, and is applied in almost all cases where one of the two data structures "runs short" of variables.

[[LARGE NOTE OF DOOM: **Warnings** are NOT **errors**!!]] A warning will be signaled when R thinks that you did something you didn't intend to do, so it will simply tell you to be careful, but the operation will be carried on nonetheless. On the other hand, an error occurs when R either doesn't know what to do next or cannot do what you asked it to do with the current data, and *the operation is not carried out*. If you see a warning, inspect it, but don't freak out. If you see an error, read what it says and try to fix the code.

### Selecting stuff inside vectors

Each element in a vector is "numbered". Indeed, each entry has an **index number**: `x <- c("A", "B", "C", "D", "E")` creates a vector with 5 entities, with index number: `[1] A ; [2] B ; [3] C ; [4] D ; [5] E`

Square brackets can be used to get determined entities out of an object:

```{r results = "hide"}
x <- c("A", "B", "C", "D", "E")

x[1] # "A"
x[3] # "C"
x[c(1,4,3)] # "A" "D" "C" Notice how we need to use a vector, and x[1,4,3] will not work.

# Negative index numbers will be excluded instead:
x[-(c(1,4,3))] # "B" "E"
```
If vectors are named (See later), you can use the name to select the elements in the same way as using their index numbers:
```{r}
experiment1 <- c(100, 200, 12.2, 3)
names(experiment1) <- c("Cell count 1", 
                        "Cell count 2", 
                        "Growth Factor", 
                        "Bananas?")

experiment1[c("Bananas?", "Cell count 2")]
```

You can also use logic expressions to select stuff inside objects. TRUE are kept, FALSE are omitted:
```{r results="hold"}
x <- c(1, 2, 3, 4, 5, NA, NA, 8, 9, NaN, 11)
x[!is.na(x)] # Is a new vector, with: 1 2 3 4 5 8 9 11

y <- c(1, NA, 3, NA, 5)
x[is.na(y)] # 2  4 NA  9 # Notice the recycling
```

## Arrays and Matrices
Matrices are bidimensional vectors, made of columns and rows. A matrix can only contain one type of element. A matrix is defined by a **dimensional vector** (accessed with the function `dim(matrix)`), which specifies its dimensions. The dimensional vector of a vector is NULL. By assigning a new two-value vector (in the form `c(ROWS, COLUMNS)`) as a dimensional vector for an existing variable, we can change it to be a matrix:
```{r}
x <- c(1:20) # Matrices need to be created from a vector

dim(x) <- c(4,5) # dim(x) is the dimension vector of x.
                 # If set to two values, it defines x as a matrix.
                 # The numbers in the dimensional vector indicate ROWS, COLUMNS.
x
```

length(x) **must** be equal to prod( dim(x) ) (so, ROWS times COLUMNS). If they are not, an error is raised and no matrix is created.
```{r}
length(x) == prod(dim(x)) # This must always be TRUE.
```
The elements of x are assigned columns-first when creating a matrix.

To create matrices easily, we can use the function `matrix()`. By consulting the help files for this function (`?matrix()`) we see that its parameters are: `matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, ...)`. Let's see some examples:
```{r results="hold"}
matrix(nr = 3, nc = 5) # This creates and empty (NA - filled) matrix of 
                       # 3 rows and 5 columns.
matrix(nr = 5, nc = 5, data = x) 
                       # matrix() ignores the length(x) == prod(dim(x)) requirement.
                       # If the vector is too short, the recycle rule applies.
```

If either `nr` or `nc` is not specified, then matrix() will generate it trying to fill the new matrix with every object in `data = x` only once.

Matrices can be accessed by giving two index numbers in the format ROW, COLUMN:
```{r results="hold"}
x <- matrix(1:20, 4, 5)

x[1,3] 
x[2,]  # Not giving an index selects the whole row or column
x[,4]

x[c(2,3), 5]
x[, c(3, 1, 5)]
```

Using `subset()` can be useful to select elements of a matrix or array. Remember to use `?subset()` to learn how to use this function.

If the matrix (or array) is named, one may access it using "[]":
```{r}
colnames(x) <- paste(rep("X", 5), 1:5, sep="")
rownames(x) <- paste(rep("Exp", dim(x)[1]), c(1:dim(x)[1]), sep="") 
                                # Note the use of dim()!
x
```
```{r results="hold"}
x[,"X2"] # This returns a vector with column 2 inside
x["Exp1",] # This returns a vector with row 2 inside.
x["Exp3", "X5"]
x[c("Exp3", "Exp4"), "X3"]
```

If a matrix has more than 2 dimensions it is called an Array. Matrices are, in fact, 2-dimensional arrays. "dim"-dimensional arrays are created by assigning `dim()` to an existing vector, or by the `array()` function. As before, assigning `dim()` must follow the `length(x) == prod(dim(x))` requirement.
```{r}
x <- c(1:40)
dim(x) <- c(2,5,4)
x

array(1:40, dim = c(2,5,2))
```

Value assignment and indexes for arrays are the same as matrices.

Assigning names to dimensions larger than 2 is tricky: Change the value of `dimnames(ARRAY)[[DIMENSION]]`, or, more simply, just specify dimnames while using `array()`.
```{r}
named <- array( data     = 1:12,
                dim      = c(3, 3, 3),
                dimnames = list( c("A", "B", "C"), # column names...
                                 c("D", "E", "F"), # 
                                 c("G", "H", "I")
                                 ))
```

If a vector and an array are multiplied, the element-by-element rule is followed. Note that **if a vector is longer than the array, an error occours**. When multiplying two arrays, if the operation's arrays have different `dim()` attributes, an error occurs.

Chaining together vectors or arrays can be done with `rbind()` or `cbind()`. `rbind()` links rows together, `cbind()` binds columns. Binding two vectors will create an array:
```{r results="hold"}
a <- array("A", dim= c(2,3))
b <- array("B", dim= c(2,3))

cbind(a,b)
cbind(b,a) # Order is important.
```
```{r results="hold"}
rbind(a,b)
rbind(b,a) # ORDER IS IMPORTANT!
```

As with vectors, we can put labels on columns and rows:
```{r}
x <- array(1:12, dim=c(3:4))

rownames(x) <- c("Name 1", "Name 2", "Name 3")
colnames(x) <- c("Col 1", "Col 2", "Col 3", "Col 4")

x
```

After setting names, we can use those instead of access numbers.

### Working with arrays

We can use basic math, as we've seen for vectors. If two matrices are not of the same dimensions, math operations give an error. Matrix multiplication can be done using `%*%`. Using "`*`" gives an element-by-element multiplication.
```{r results="hide"}
a <- array(1:20, dim = c(2,4))
b <- array(45:1, dim = c(2,4))

a+b ; a*b ; a / b ; a ^ b # Since a and b have the same dim(), this is doable.

c <- array(20:25, dim = c(3,2))

a + c ; b * c ; c ^ b # Error, error, error. 
                      # c has different dim() from either a or b, so these functions would return errors.
```

Applying a function to the array returns element-by-element results:
```{r results="hold"}
a <- array(1:6, dim=c(2,3))
mean(a)
prod(a)
log(a)
```

To apply a function to each row or column, use `apply()`. Looking at the manual: `apply(array, MARGIN, FUN, ...)`. The MARGIN variable is 1 for rows and 2 for columns.
```{r results="hold"}
apply(a, 1, sum)
apply(a, 2, sum)
apply(a, 1, prod)
apply(a, 2, mean)
```
